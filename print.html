<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>SuperStruct Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-29aef1fc.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-57a2e618.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">SuperStruct Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>SuperStruct is a Rust library for working with versioned data. It allows you to define and operate
on <em>variants</em> of a <code>struct</code> which share some fields in common.</p>
<p>As an example, imagine you’re working on a program that accepts a <code>Request</code> struct from the user.
In the first version of the program you only allow users to specify a <code>start: u16</code> field:</p>
<pre class="playground"><code class="language-rust no_run no_playground"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Request {
    start: u16,
}
<span class="boring">}</span></code></pre>
<p>After a while you realise that it would be nice if users could also specify an <code>end: u16</code> in their
requests, so you would like to change the definition of <code>Request</code> to:</p>
<pre class="playground"><code class="language-rust no_run no_playground"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Request {
    start: u16,
    end: u16,
}
<span class="boring">}</span></code></pre>
<p>Now imagine that your program needs to work with old versions of <code>Request</code> as well as new, i.e.
it needs to be backwards-compatible. This is reasonably common when databases are involved and
you need to write schema migrations, or when working with network protocols.</p>
<p>SuperStruct allows you to define <em>both</em> versions of the <code>Request</code> with a single definition, and
also generates an enum to unify them:</p>
<pre><code class="language-rust no_run noplayground">use superstruct::superstruct;

#[superstruct(variants(V1, V2))]
pub struct Request {
    pub start: u16,
    #[superstruct(only(V2))]
    pub end: u16,
}

#[cfg_attr(test, test)]
fn main() {
    let r1 = Request::V1(RequestV1 { start: 0 });
    let r2 = Request::V2(RequestV2 { start: 0, end: 10 });

    assert_eq!(r1.start(), r2.start());
    assert_eq!(r1.end(), Err(()));
    assert_eq!(r2.end(), Ok(&amp;10));
}</code></pre>
<p>The <code>superstruct</code> definition generates:</p>
<ul>
<li>Two structs <code>RequestV1</code> and <code>RequestV2</code> where the <code>end</code> field is only present in <code>RequestV2</code>.</li>
<li>An enum <code>Request</code> with variants <code>V1</code> and <code>V2</code> wrapping <code>RequestV1</code> and <code>RequestV2</code> respectively.</li>
<li>A getter function on <code>Request</code> for the shared <code>start</code> field, e.g. <code>r1.start()</code>.</li>
<li>A <em>partial</em> getter function returning <code>Result&lt;&amp;u16, ()&gt;</code> for <code>end</code>, e.g. <code>r2.end()</code>.</li>
<li>Lots of other useful goodies that are covered in the <a href="#code-generation">Codegen</a> section of the book.</li>
</ul>
<h2 id="when-should-you-use-superstruct"><a class="header" href="#when-should-you-use-superstruct">When <em>should</em> you use SuperStruct?</a></h2>
<ul>
<li>If you want to avoid duplication when defining multiple related structs.</li>
<li>If you are considering manually writing getters to extract common fields from an enum.</li>
<li>If you are considering writing traits to unify types with fields in common.</li>
</ul>
<h2 id="when-should-you-not-use-superstruct"><a class="header" href="#when-should-you-not-use-superstruct">When should you <em>not</em> use SuperStruct?</a></h2>
<ul>
<li>If you can get away with just using an <code>Option</code> field. In our example, <code>Request</code> could define
<code>end: Option&lt;u16&gt;</code>.</li>
<li>If you can achieve backwards compatible (de)serialization through clever use of <code>serde</code> macros.</li>
</ul>
<h2 id="what-next"><a class="header" href="#what-next">What next?</a></h2>
<ul>
<li>Check out the <a href="#code-generation">Code Generation</a> docs.</li>
<li>Check out the <a href="#configuration">Configuration</a> docs for information on how to
control <code>superstruct</code>’s behaviour, including renaming getters, working with
<code>Copy</code> types, etc.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<p>To use SuperStruct in your project add <code>superstruct</code> as a dependency in your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">superstruct = "0.4.0"
</code></pre>
<p>For the latest published version please consult <a href="https://crates.io/crates/superstruct"><code>crates.io</code></a>.</p>
<hr>
<p>To use SuperStruct, import the <code>superstruct</code> procedural macro with <code>use superstruct::superstruct</code>,
like so:</p>
<pre><code class="language-rust no_run noplayground">use superstruct::superstruct;

#[superstruct(variants(V1, V2))]
pub struct Request {
    pub start: u16,
    #[superstruct(only(V2))]
    pub end: u16,
}

#[cfg_attr(test, test)]
fn main() {
    let r1 = Request::V1(RequestV1 { start: 0 });
    let r2 = Request::V2(RequestV2 { start: 0, end: 10 });

    assert_eq!(r1.start(), r2.start());
    assert_eq!(r1.end(), Err(()));
    assert_eq!(r2.end(), Ok(&amp;10));
}</code></pre>
<p>For more information on this example see the <a href="#introduction">Introduction</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="code-generation"><a class="header" href="#code-generation">Code generation</a></h1>
<p>SuperStruct generates several types, methods and trait implementations.</p>
<p>You should visit each of the sub-pages in order to understand how the generated code fits together:</p>
<ol>
<li><a href="#variant-structs">Variant structs</a>.</li>
<li><a href="#top-level-enum">Top-level enum</a>.</li>
<li><a href="#ref-and-refmut"><code>Ref</code> and <code>RefMut</code></a>.</li>
<li><a href="#mapping-macros">Mapping macros</a>.</li>
<li><a href="#meta-variant-structs-and-enums">Meta variant structs and enums</a>.</li>
</ol>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>For a full, up-to-date example of the code generated, please see the <a href="rustdoc/request">RustDoc output for
the <code>Request</code> example</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="variant-structs"><a class="header" href="#variant-structs">Variant structs</a></h1>
<p>The most basic items generated by SuperStruct are the variant structs. For each
variant listed in the top-level <code>superstruct(variants(..)</code> list, a struct with
the name <code>{BaseName}{VariantName}</code> will be created. For example:</p>
<pre class="playground"><code class="language-rust no_run no_playground"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[superstruct(variants(Foo, Bar))]
struct MyStruct {
    name: String,
    #[superstruct(only(Foo))]
    location: u16,
}
<span class="boring">}</span></code></pre>
<p>Here the <code>BaseName</code> is <code>MyStruct</code> and there are two variants called <code>Foo</code> and <code>Bar</code>.</p>
<p>The generated variant structs are:</p>
<pre class="playground"><code class="language-rust no_run no_playground"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyStructFoo {
    name: String,
    location: u16,
}

struct MyStructBar {
    name: String,
}
<span class="boring">}</span></code></pre>
<p>Note how the <code>only</code> attribute controls the presence of fields in each variant.
For more information see <a href="#struct-attributes">Struct attributes</a>.</p>
<p>The variant structs are unified as part of the <a href="#top-level-enum">top-level enum</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="top-level-enum"><a class="header" href="#top-level-enum">Top-level enum</a></h1>
<p>SuperStruct generates an enum that combines all of the generated variant structs.</p>
<p>Consider the <code>MyStruct</code> example from the previous page:</p>
<pre class="playground"><code class="language-rust no_run no_playground"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[superstruct(variants(Foo, Bar))]
struct MyStruct {
    name: String,
    #[superstruct(only(Foo))]
    location: u16,
}
<span class="boring">}</span></code></pre>
<p>The generated enum is:</p>
<pre class="playground"><code class="language-rust no_run no_playground"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum MyStruct {
    Foo(MyStructFoo),
    Bar(MyStructBar),
}
<span class="boring">}</span></code></pre>
<p>The enum has one variant per variant in <code>superstruct(variants(..))</code>, and each
variant contains its generated variant struct. It is named <code>{BaseName}</code>.</p>
<p>Generation of the top-level enum can be disabled using the <code>no_enum</code> attribute. For more information
see the <a href="#struct-attributes">Struct attributes</a>.</p>
<h2 id="getters-and-setters"><a class="header" href="#getters-and-setters">Getters and setters</a></h2>
<p>The top-level enum has getters and setters for each of the variant fields. They are named:</p>
<ul>
<li><code>{field_name}()</code> for getters.</li>
<li><code>{field_name}_mut()</code> for setters.</li>
</ul>
<p>If a field is common to all variants, then the getters and setters are <em>total</em> and return <code>&amp;T</code>
and <code>&amp;mut T</code> respectively, where <code>T</code> is the type of the field.</p>
<p>If a field is part of some variants but not others, then the getters and
setters are <em>partial</em> and return <code>Result&lt;&amp;T, E&gt;</code> and <code>Result&lt;&amp;mut T, E&gt;</code>
respectively.</p>
<p>Many aspects of the getters and setters can be configured, including their
names, whether they <code>Copy</code> and which error type <code>E</code> is used.
See <a href="#field-attributes">Field attributes</a>.</p>
<h2 id="casting-methods"><a class="header" href="#casting-methods">Casting methods</a></h2>
<p>The top-level enum has methods to <em>cast</em> it to each of the variants:</p>
<ul>
<li><code>as_{variantname}</code> returning <code>Result&lt;&amp;{VariantStruct}, E&gt;</code>.</li>
<li><code>as_{variantname}_mut</code> returning <code>Result&lt;&amp;mut {VariantStruct}, E&gt;</code>.</li>
</ul>
<p>The error type <code>E</code> may be controlled by the <a href="#cast-error"><code>cast_error</code> attribute</a>.</p>
<h2 id="reference-methods"><a class="header" href="#reference-methods">Reference methods</a></h2>
<p>The top-level enum has methods for converting it into the <code>Ref</code> and <code>RefMut</code> types, which
are described <a href="#ref-and-refmut">here</a>.</p>
<ul>
<li><code>to_ref</code> returning <code>{BaseName}Ref</code>.</li>
<li><code>to_mut</code> returning <code>{BaseName}RefMut</code>.</li>
</ul>
<h2 id="from-implementations"><a class="header" href="#from-implementations"><code>From</code> implementations</a></h2>
<p>The top-level enum has <code>From</code> implementations for converting (owned) variant structs, i.e.</p>
<ul>
<li><code>impl From&lt;{VariantStruct}&gt; for {BaseName}</code> for all variants</li>
</ul>
<h2 id="attributes-on-the-enum-variants"><a class="header" href="#attributes-on-the-enum-variants">Attributes on the enum variants</a></h2>
<p>To add attributes to the enum variants, <code>enum_variant_attributes</code> and <code>specific_enum_variant_attributes</code>
can be used.</p>
<p>Consider a variant of the <code>MyStruct</code> example where you want to derive <code>serde::Serialize</code>. However, one
of the fields has a lifetime thus the <code>#[serde(borrow)]</code> attribute is required on the enum variants.
In addition, you want to change the name of one of the enum variants when it’s serialized:</p>
<pre class="playground"><code class="language-rust no_run no_playground"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[superstruct(
    variants(Foo, Bar),
    enum_variant_attributes(serde(borrow)),
    specific_enum_variant_attributes(Bar(serde(rename = "Baz"))),
)]
#[derive(serde::Serialize)]
struct MyStruct&lt;'a&gt; {
    name: &amp;'a str,
    #[superstruct(only(Foo))]
    location: u16,
}
<span class="boring">}</span></code></pre>
<p>The generated enum is:</p>
<pre class="playground"><code class="language-rust no_run no_playground"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(serde::Serialize)]
enum MyStruct&lt;'a&gt; {
    #[serde(borrow)]
    Foo(MyStructFoo&lt;'a&gt;),
    #[serde(borrow, rename = "Baz")]
    Bar(MyStructBar&lt;'a&gt;),
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ref-and-refmut"><a class="header" href="#ref-and-refmut"><code>Ref</code> and <code>RefMut</code></a></h1>
<p>SuperStruct generates two reference-like structs which are designed to simplify working with nested
<code>superstruct</code> types.</p>
<p>The immutable reference type is named <code>{BaseName}Ref</code> and has all of the immutable getter methods
from the top-level enum.</p>
<p>The mutable reference type is named <code>{BaseName}RefMut</code> and has all of the mutable getter methods
from the top-level enum.</p>
<p>Consider the <code>MyStruct</code> example again:</p>
<pre class="playground"><code class="language-rust no_run no_playground"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[superstruct(variants(Foo, Bar))]
struct MyStruct {
    name: String,
    #[superstruct(only(Foo))]
    location: u16,
}
<span class="boring">}</span></code></pre>
<p>The generated <code>Ref</code> types look like this:</p>
<pre class="playground"><code class="language-rust no_run no_playground"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum MyStructRef&lt;'a&gt; {
    Foo(&amp;'a MyStructFoo),
    Bar(&amp;'a MyStructBar),
}

enum MyStructRefMut&lt;'a&gt; {
    Foo(&amp;'a mut MyStructFoo),
    Bar(&amp;'a mut MyStructFoo),
}
<span class="boring">}</span></code></pre>
<p>The reason these types can be useful (particularly with nesting) is that they do not require a full
reference to a <code>MyStruct</code> in order to construct: a reference to a single variant struct will suffice.</p>
<h2 id="trait-implementations"><a class="header" href="#trait-implementations">Trait Implementations</a></h2>
<h3 id="copy"><a class="header" href="#copy"><code>Copy</code></a></h3>
<p>Each <code>Ref</code> type is <code>Copy</code>, just like an ordinary <code>&amp;T</code>.</p>
<h3 id="from"><a class="header" href="#from"><code>From</code></a></h3>
<p>The <code>Ref</code> type has <code>From</code> implementations that allow converting from references to variants
or references to the top-level enum type, i.e.</p>
<ul>
<li><code>impl From&lt;&amp;'a {VariantStruct}&gt; for {BaseName}Ref&lt;'a&gt;</code> for all variants.</li>
<li><code>impl From&lt;&amp;'a {BaseName}&gt; for {BaseName}Ref&lt;'a&gt;</code> (same as <code>to_ref()</code>).</li>
</ul>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<p>Please see <a href="rustdoc/src/nested/nested.rs.html"><code>examples/nested.rs</code></a> and its
generated <a href="rustdoc/nested">documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="mapping-macros"><a class="header" href="#mapping-macros">Mapping macros</a></h1>
<p>To facilitate code that is generic over all variants of a <code>superstruct</code>, we generate several
<em>mapping macros</em> with names like <code>map_foo!</code> and <code>map_foo_into_bar!</code>.</p>
<h2 id="mapping-into-self"><a class="header" href="#mapping-into-self">Mapping into <code>Self</code></a></h2>
<p>For every top-level enum we generate a mapping macro that matches on values of
<code>Self</code> and is equipped with a variant constructor for <code>Self</code>.</p>
<p>Consider the following type:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[superstruct(variants(First, Second)]
struct Foo {
    x: u8,
    #[only(Second)]
    y: u8
}
<span class="boring">}</span></code></pre>
<p>The mapping macro for <code>Foo</code> will be:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! map_foo {
    ($value:expr, $f:expr) =&gt; {
        match $value {
            Foo::First(inner) =&gt; f(inner, Foo::First),
            Foo::Second(inner) =&gt; f(inner, Foo::Second),
        }
    }
}
<span class="boring">}</span></code></pre>
<p>i.e. <code>map_foo!</code> is a macro taking two arguments:</p>
<ul>
<li><code>value</code>: an expression which must be of type <code>Foo</code>.</li>
<li><code>f</code>: a function expression, which takes two arguments <code>|inner, constructor|</code> where:
<ul>
<li><code>inner</code> is an instance of a variant struct, e.g. <code>FooFirst</code>. Note that
its type changes between branches!</li>
<li><code>constructor</code> is a function from the selected variant struct type to <code>Foo</code>. Its type
also changes between branches, and would be e.g. <code>fn(FooFirst) -&gt; Foo</code> in the case
of the <code>First</code> branch.</li>
</ul>
</li>
</ul>
<p>Example usage looks like this:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Foo {
    fn increase_x(self) -&gt; Self {
        map_foo!(self, |inner, constructor| {
            inner.x += 1;
            constructor(inner)
        })
    }
}
<span class="boring">}</span></code></pre>
<p>Although the type of <code>inner</code> could be <code>FooFirst</code> or <code>FooSecond</code>, both have an <code>x</code> field, so it is
legal to increment it. The <code>constructor</code> is then used to re-construct an instance of <code>Foo</code> by
injecting the updated <code>inner</code> value. If an invalid closure is provided then the type errors may
be quite opaque. On the other hand, if your code type-checks while using <code>map!</code> then you can rest
assured that it is valid (<code>superstruct</code> doesn’t use any <code>unsafe</code> blocks or do any spicy casting).</p>
<blockquote>
<p>Tip: You don’t need to use the constructor argument if you are implementing a straight-forward
projection on <code>Self</code>. Although in some cases you may need to provide a type
hint to the compiler, like <code>let _ = constructor(inner)</code>.</p>
</blockquote>
<h2 id="mapping-from-ref-and-refmut"><a class="header" href="#mapping-from-ref-and-refmut">Mapping from <code>Ref</code> and <code>RefMut</code></a></h2>
<p>Mapping macros for <code>Ref</code> and <code>RefMut</code> are also generated. They take an extra lifetime argument
(supplied as a reference to <code>_</code>) as their first argument, which must correspond to the lifetime
on the <code>Ref</code>/<code>RefMut</code> type.</p>
<p>Example usage for <code>Foo</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Foo {
    fn get_x&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a u64 {
        map_foo_ref!(&amp;'a _, self, |inner, _| {
            &amp;inner.x
        })
    }
}
<span class="boring">}</span></code></pre>
<h2 id="mapping-into-other-types"><a class="header" href="#mapping-into-other-types">Mapping into other types</a></h2>
<p>Mappings can also be generated between two <code>superstruct</code>s with identically named variants.</p>
<p>These mapping macros are available for the top-level enum, <code>Ref</code> and <code>RefMut</code>, and take the same
number of arguments. The only difference is that the constructor will be the constructor for the
type being mapped <em>into</em>.</p>
<p>The name of the mapping macro is <code>map_X_into_Y!</code> where <code>X</code> is the snake-cased
<code>Self</code> type and <code>Y</code> is the snake-cased target type.</p>
<p>Example:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[superstruct(
    variants(A, B),
    variant_attributes(derive(Debug, PartialEq, Clone)),
    map_into(Thing2),
    map_ref_into(Thing2Ref),
    map_ref_mut_into(Thing2RefMut)
)]
#[derive(Debug, PartialEq, Clone)]
pub struct Thing1 {
    #[superstruct(only(A), partial_getter(rename = "thing2a"))]
    thing2: Thing2A,
    #[superstruct(only(B), partial_getter(rename = "thing2b"))]
    thing2: Thing2B,
}

#[superstruct(variants(A, B), variant_attributes(derive(Debug, PartialEq, Clone)))]
#[derive(Debug, PartialEq, Clone)]
pub struct Thing2 {
    x: u64,
}

fn thing1_to_thing2(thing1: Thing1) -&gt; Thing2 {
    map_thing1_into_thing2!(thing1, |inner, cons| { cons(inner.thing2) })
}

fn thing1_ref_to_thing2_ref&lt;'a&gt;(thing1: Thing1Ref&lt;'a&gt;) -&gt; Thing2Ref&lt;'a&gt; {
    map_thing1_ref_into_thing2_ref!(&amp;'a _, thing1, |inner, cons| { cons(&amp;inner.thing2) })
}

fn thing1_ref_mut_to_thing2_ref_mut&lt;'a&gt;(thing1: Thing1RefMut&lt;'a&gt;) -&gt; Thing2RefMut&lt;'a&gt; {
    map_thing1_ref_mut_into_thing2_ref_mut!(&amp;'a _, thing1, |inner, cons| {
        cons(&amp;mut inner.thing2)
    })
}
<span class="boring">}</span></code></pre>
<h2 id="naming"><a class="header" href="#naming">Naming</a></h2>
<p>Type names are converted from <code>CamelCase</code> to <code>snake_case</code> on a best-effort basis. E.g.</p>
<ul>
<li><code>SignedBeaconBlock</code> -&gt; <code>map_signed_beacon_block!</code></li>
<li><code>NetworkDht</code> -&gt; <code>map_network_dht!</code></li>
</ul>
<p>The current algorithm is quite simplistic and may produce strange names if it encounters
repeated capital letters. Please open an issue on GitHub if you have suggestions on how to
improve this!</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<ul>
<li>Presently only pure mapping functions are supported. The type-hinting hacks make it hard to
support proper closures.</li>
<li>Sometimes type-hints are required, e.g. <code>let _ = constructor(inner)</code>.</li>
<li>Macros are scoped per-module, so you need to be more mindful of name collisions than when
defining regular types.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="meta-variant-structs-and-enums"><a class="header" href="#meta-variant-structs-and-enums">Meta variant structs and enums</a></h1>
<p>Meta variants are an optional feature, useful for scenarios where you’d want nested
enums at the top-level. structs will be created for all combinations of <code>meta_variants</code>
and <code>variants</code>, names in the format <code>{BaseName}{MetaVariantName}{VariantName}</code>.
Additionally, enums will be created for each <code>meta_variant</code> named <code>{BaseName}{MetaVariantName}</code>.</p>
<p>For example:</p>
<pre class="playground"><code class="language-rust no_run no_playground"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[superstruct(meta_variants(Baz, Qux), variants(Foo, Bar))]
struct MyStruct {
    name: String,
    #[superstruct(only(Foo))]
    location: u16,
    #[superstruct(meta_only(Baz))]
    score: u64,
    #[superstruct(only(Bar), meta_only(Qux))]
    id: usize,
}
<span class="boring">}</span></code></pre>
<p>Here the <code>BaseName</code> is <code>MyStruct</code> and there are two variants in the meta-enum called
<code>Baz</code> and <code>Qux</code>.</p>
<p>The generated enums are:</p>
<pre class="playground"><code class="language-rust no_run no_playground"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum MyStruct {
    Baz(MyStructBaz),
    Qux(MyStructQux),
}

enum MyStructBaz {
    Foo(MyStructBazFoo),
    Bar(MyStructBazBar),
}

enum MyStructQux {
    Foo(MyStructQuxFoo),
    Bar(MyStructQuxBar),
}
<span class="boring">}</span></code></pre>
<p>The generated variant structs are:</p>
<pre class="playground"><code class="language-rust no_run no_playground"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyStructBazFoo {
    name: String,
    location: u16,
    score: u64,
}

struct MyStructBazBar {
    name: String,
    score: u64,
}

struct MyStructQuxFoo {
    name: String,
    location: u16,
}

struct MyStructQuxBar {
    name: String,
    id: usize,
}
<span class="boring">}</span></code></pre>
<p>Note how the <code>only</code> attribute still applies, and a new <code>meta_only</code> attribute can be used to
control the presence of fields in each meta variant.</p>
<p>For more information see <a href="#struct-attributes">Struct attributes</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>SuperStruct is a procedural macro, and is configured by <code>superstruct</code> attributes on the
type being defined.</p>
<ul>
<li><a href="#struct-attributes">Struct attributes</a> are applied to the top-level type and configure
properties relevant to that, as well as defaults for error types.</li>
<li><a href="#field-attributes">Field attributes</a> are applied to each struct field and determine
the fields of variants, as well as the characteristics of getters and setters.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="struct-attributes"><a class="header" href="#struct-attributes">Struct attributes</a></h1>
<p>The following attributes may be used in a <code>superstruct</code> macro invocation on a
<code>struct</code> item. All attributes are optional unless stated otherwise.</p>
<h2 id="variants"><a class="header" href="#variants">Variants</a></h2>
<pre><code>#[superstruct(variants(A, B, ...))]
</code></pre>
<p>Define the list of variants that this type has.
See <a href="#variant-structs">variant structs</a>.</p>
<p>The <code>variants</code> attribute is <em>not optional</em>.</p>
<p><strong>Format</strong>: 1+ comma-separated identifiers.</p>
<h2 id="cast-error"><a class="header" href="#cast-error">Cast error</a></h2>
<pre><code>#[superstruct(cast_error(ty = "..", expr = ".."))]
</code></pre>
<p>Define the error type to be returned from <a href="#casting-methods">casting methods</a>.</p>
<p>The expression must be of the given error type, and capable of being evaluated without any
context (it is <em>not</em> a closure).</p>
<p><strong>Format</strong>: quoted type for <code>ty</code>, quoted expression for <code>expr</code></p>
<h2 id="partial-getter-error"><a class="header" href="#partial-getter-error">Partial getter error</a></h2>
<pre><code>#[superstruct(cast_error(ty = "..", expr = ".."))]
</code></pre>
<p>Define the error type to be returned from <a href="#getters-and-setters">partial getter
methods</a>.</p>
<p>The expression must be of the given error type, and capable of being evaluated without any
context (it is <em>not</em> a closure).</p>
<p><strong>Format</strong>: quoted type for <code>ty</code>, quoted expression for <code>expr</code></p>
<h2 id="variant-attributes"><a class="header" href="#variant-attributes">Variant attributes</a></h2>
<pre><code>#[superstruct(variant_attributes(...))]
</code></pre>
<p>Provide a list of attributes to be applied verbatim to each variant struct definition.</p>
<p>This can be used to derive traits, perform conditional compilation, etc.</p>
<p><strong>Format</strong>: any.</p>
<h2 id="specific-variant-attributes"><a class="header" href="#specific-variant-attributes">Specific variant attributes</a></h2>
<pre><code>#[superstruct(specific_variant_attributes(A(...), B(...), ...))]
</code></pre>
<p>Similar to <code>variant_attributes</code>, but applies the attributes <em>only</em> to the named variants. This
is useful if e.g. one variant needs to derive a trait which the others cannot, or if another
procedural macro is being invoked on the variant struct which requires different parameters.</p>
<p><strong>Format</strong>: zero or more variant names, with variant attributes nested in parens</p>
<h2 id="enum-variant-attributes"><a class="header" href="#enum-variant-attributes">Enum variant attributes</a></h2>
<pre><code>#[superstruct(enum_variant_attributes(...))]
</code></pre>
<p>Provide a list of attributes to be applied verbatim to each of the enum variants.</p>
<p>This is useful when using another proc-macro on the enum and needing to add an attribute
to all enum variants.</p>
<p><strong>Format</strong>: any.</p>
<h2 id="specific-enum-variant-attributes"><a class="header" href="#specific-enum-variant-attributes">Specific enum variant attributes</a></h2>
<pre><code>#[superstruct(specific_enum_variant_attributes(A(...), B(...), ...))]
</code></pre>
<p>Similar to <code>enum_variant_attributes</code>, but applies the attributes only to the named enum variants.
This is useful if e.g. one enum variant needs an attribute while the others cannot.</p>
<p><strong>Format</strong>: zero or more variant names, with enum variant attributes nested in parens.</p>
<h2 id="ref-attributes"><a class="header" href="#ref-attributes"><code>Ref</code> attributes</a></h2>
<pre><code>#[superstruct(ref_attributes(...))]
</code></pre>
<p>Provide a list of attributes to be applied verbatim to the generated <code>Ref</code> type.</p>
<p><strong>Format</strong>: any.</p>
<h2 id="refmut-attributes"><a class="header" href="#refmut-attributes"><code>RefMut</code> attributes</a></h2>
<pre><code>#[superstruct(ref_mut_attributes(...))]
</code></pre>
<p>Provide a list of attributes to be applied verbatim to the generated <code>RefMut</code> type.</p>
<p><strong>Format</strong>: any.</p>
<h2 id="no-enum"><a class="header" href="#no-enum">No enum</a></h2>
<pre><code>#[superstruct(no_enum)]
</code></pre>
<p>Disable generation of the top-level enum, and all code except the
<a href="#variant-structs">variant structs</a>.</p>
<h2 id="map-into"><a class="header" href="#map-into">Map Into</a></h2>
<pre><code>#[map_into(ty1, ty2, ..)]
#[map_ref_into(ty1, ty2, ..)]
#[map_ref_mut_into(ty1, ty2, ..)]
</code></pre>
<p>Generate mapping macros from the top-level enum, the <code>Ref</code> type or the <code>RefMut</code> type as appropriate.</p>
<p>Please see the documentation on <a href="#mapping-into-other-types">Mapping into other types</a>
for an explanation of how these macros operate.</p>
<p><strong>Format</strong>: one or more <code>superstruct</code> type names</p>
<h2 id="meta-variants"><a class="header" href="#meta-variants">Meta variants</a></h2>
<pre><code>#[superstruct(meta_variants(A, B, ...), variants(C, D, ...))]
</code></pre>
<p>Generate a two-dimensional superstruct.
See <a href="#meta-variant-structs-and-enums">meta variant structs</a>.</p>
<p>The <code>meta_variants</code> attribute is optional.</p>
<p><strong>Format</strong>: 1+ comma-separated identifiers.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="field-attributes"><a class="header" href="#field-attributes">Field attributes</a></h1>
<p>Field attributes may be applied to fields within a <code>struct</code> that has a <code>superstruct</code> attribute
to it at the top-level.</p>
<p>All attributes are optional.</p>
<h2 id="only"><a class="header" href="#only">Only</a></h2>
<pre><code>#[superstruct(only(A, B, ...))]
</code></pre>
<p>Define the list of variants that this field is a member of.</p>
<p>The <code>only</code> attribute is currently the only way that different variants are
created.</p>
<p>The selected variants should be a subset of the variants defined in the top-level
<a href="#variants"><code>variants</code></a> attribute.</p>
<p><strong>Format</strong>: 1+ comma-separated identifiers.</p>
<h2 id="getter"><a class="header" href="#getter">Getter</a></h2>
<pre><code>#[superstruct(getter(copy, ..))]
#[superstruct(getter(no_mut, ..))]
#[superstruct(getter(rename = "..", ..))]
</code></pre>
<p>Customise the implementation of the <a href="#getters-and-setters">getter functions</a> for
this field.</p>
<p>This attribute can only be applied to <strong>common</strong> fields (i.e. ones with no <code>only</code> attribute).</p>
<p>All of the sub-attributes <code>copy</code>, <code>no_mut</code> and <code>rename</code> are optional and any subset of them
may be applied in a single attribute, e.g. <code>#[superstruct(getter(copy, no_mut))]</code> is valid.</p>
<ul>
<li><code>copy</code>: return <code>T</code> rather than <code>&amp;T</code> where <code>T</code> is the type of the field. <code>T</code> must be <code>Copy</code>
or the generated code will fail to typecheck.</li>
<li><code>no_mut</code>: do not generate a mutating getter with <code>_mut</code> suffix.</li>
<li><code>rename = "name"</code>: rename the immutable getter to <code>name()</code> and the mutable getter to <code>name_mut()</code>
(if enabled).</li>
</ul>
<h2 id="partial-getter"><a class="header" href="#partial-getter">Partial getter</a></h2>
<pre><code>#[superstruct(partial_getter(copy, ..))]
#[superstruct(partial_getter(no_mut, ..))]
#[superstruct(partial_getter(rename = "..", ..))]
</code></pre>
<p>Customise the implementation of the <a href="#getters-and-setters">partial getter
functions</a> for this field.</p>
<p>This attribute can only be applied to <strong><em>non</em>-common</strong> fields (i.e. ones <em>with</em> an <code>only</code> attribute).</p>
<p>All of the sub-attributes <code>copy</code>, <code>no_mut</code> and <code>rename</code> are optional and any subset of them
may be applied in a single attribute, e.g. <code>#[superstruct(partial_getter(copy, no_mut))]</code> is valid.</p>
<ul>
<li><code>copy</code>: return <code>Result&lt;T, E&gt;</code> rather than <code>Result&lt;&amp;T, E&gt;</code> where <code>T</code> is the type of the field. <code>T</code>
must be <code>Copy</code> or the generated code will fail to typecheck.</li>
<li><code>no_mut</code>: do not generate a mutating getter with <code>_mut</code> suffix.</li>
<li><code>rename = "name"</code>: rename the immutable partial getter to <code>name()</code> and the mutable partial getter
to <code>name_mut()</code> (if enabled).</li>
</ul>
<p>The error type for partial getters can currently only be configured on a per-struct basis
via the <a href="#partial-getter-error"><code>partial_getter_error</code></a> attribute, although this may
change in a future release.</p>
<h2 id="no-getter"><a class="header" href="#no-getter">No Getter</a></h2>
<p>Disable the generation of (partial) getter functions for this field.
This can be used for when two fields have the same name but different types:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[superstruct(variants(A, B))]
struct NoGetter {
    #[superstruct(only(A), no_getter)]
    pub x: u64,
    #[superstruct(only(B), no_getter)]
    pub x: String,
}
<span class="boring">}</span></code></pre>
<h2 id="flatten"><a class="header" href="#flatten">Flatten</a></h2>
<pre><code>#[superstruct(flatten)]
</code></pre>
<p>This attribute can only be applied to enum fields with variants that match each variant of the
superstruct. This is useful for nesting superstructs whose variant types should be linked.</p>
<p>This will automatically create a partial getter for each variant. The following two examples are equivalent.</p>
<p>Using <code>flatten</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[superstruct(variants(A, B))]
struct InnerMessage {
    pub x: u64,
    pub y: u64,
}

#[superstruct(variants(A, B))]
struct Message {
    #[superstruct(flatten)]
    pub inner: InnerMessage,
}
<span class="boring">}</span></code></pre>
<p>Equivalent without <code>flatten</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[superstruct(variants(A, B))]
struct InnerMessage {
    pub x: u64,
    pub y: u64,
}

#[superstruct(variants(A, B))]
struct Message {
    #[superstruct(only(A), partial_getter(rename = "inner_a"))]
    pub inner: InnerMessageA,
    #[superstruct(only(B), partial_getter(rename = "inner_b"))]
    pub inner: InnerMessageB,
}
<span class="boring">}</span></code></pre>
<p>If you wish to only flatten into only a subset of variants, you can define them like so:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[superstruct(variants(A, B))]
struct InnerMessage {
    pub x: u64,
    pub y: u64,
}

#[superstruct(variants(A, B, C))]
struct Message {
    #[superstruct(flatten(A,B))]
    pub inner: InnerMessage,
}
<span class="boring">}</span></code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
